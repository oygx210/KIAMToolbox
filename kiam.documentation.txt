NAME
    kiam

DESCRIPTION
    This Python module is a part of the KIAM Astrodynamics Toolbox developed in        
    Keldysh Institute of Applied Mathematics (KIAM), Moscow, Russia.

    The module serves as a safe and convenient interface to Fortran-compiled
    astrodynamical routines and provides instruments for performing translations       
    between variables, coordinate systems, and time descriptions, propagating the      
    trajectories in various models, and getting fast answers on typical
    questions about the two and n-body problems. It also contains some plotting       
    routins and useful matrix linear algebra operations.

    The toolbox is licensed under the MIT License.

    For more information see GitHub page of the project:
    https://github.com/shmaxg/KIAMToolbox

FUNCTIONS
    astro_const() -> tuple
        Get astronomical constants.

        Returns:
        --------
        uni_const : dict
            Universal constants containing the speed of light (SoL) in km/s,
            astronomical unit (AU) in km, constant of gravitation (G) in km^3/kg/s^2, 
            standard acceleration due to gravity (g0) in m/s^2, degrees in 1 radian (RA
D).
        star : dict
            Contains constants of the Sun: the gravitational parameter (GM) in km^3/s^2
,
            the mean radius (MeanRadius) in km.
        planet : dict
            Contains constants of the planets (Mercury, Venus, Earth, Mars, Jupiter,  
            Saturn, Uranus, Neptune). The keys of the dictionary are the names of the p
lanets.
            Eack planet[planet_name] is also a dictionary that contains the
            gravitational parameter of the planet (GM) in km^3/s^2,
            the mean raidus (MeanRadius) in km, the equator radius (EquatorRadius) in k
m,
            the semi-major axis of the orbit around the Sun (SemimajorAxis) in km. For 
the Earth
            there are additionaly the obliquity of the ecliptic (Obliquity) in degrees
            and its time derivative (dObliquitydt) in arcsec/cy (cy = century years). 
        moon : dict
            Contains constants of the moons (currently only of the Moon). The dictionar
y
            has a single key named Moon and moon['Moon'] is also a dictionary.        
            That dictionary contains the gravitational parameter of the Moon (GM) in km
^3/s^2,
            the mean raidus (MeanRadius) in km,
            the semi-major axis of the orbit around the Sun (SemimajorAxis) in km.    
        small_body : dict
            Contains constants of the small celestial bodies (currently only of the Plu
to).
            The dictionary has a single key named Pluto and small_body['Pluto'] is also
 a
            dictionary. That dictionary contains the
            gravitational parameter of the Pluto (GM) in km^3/s^2,
            the mean raidus (MeanRadius) in km, the equator radius (EquatorRadius) in k
m,
            the semi-major axis of the orbit around the Sun (SemimajorAxis) in km.    

    boxplot(x, ax=None, xlabel='', ylabel='', show=False, saveto=False)

    cart2latlon(cart: numpy.ndarray) -> numpy.ndarray
        Cartesian coordinates to latitude and longitude.

        Parameters:
        -----------
        cart : numpy.ndarray, shape (3,), (3, n)
            3D vector or array of column 3D vectors of Cartesian coordinates
            Vector structure: [x, y, z]

        Returns:
        --------
        latlon : numpy.ndarray, shape (2,), (2, n)
            2D Vector or array of column 2D vectors of latitude and longitude pairs.  
            Vector structure: [lat, lon], where
            lat in [-pi/2, pi/2],
            lon in [-pi, pi]

    cart2sphere(cart: numpy.ndarray) -> numpy.ndarray
        Cartesian coordinates to spherical coordinates.

        Parameters:
        -----------
        cart : numpy.ndarray, shape (3, n)
            Array of column 3D vectors of Cartesian coordinates
            Vector structure: [x, y, z]

        Returns:
        --------
        sphere : numpy.ndarray, shape (3, n)
            Array of column 3D vectors of spherical coordinates
            Vector structure: [r, phi, theta], where
            phi in [-pi, pi],
            theta in [0, pi],
            x = r*cos(theta)*cos(phi),
            y = r*cos(theta)*sin(phi),
            z = r*sin(theta)

    cosd(x: Union[float, numpy.ndarray]) -> Union[float, numpy.ndarray]
        Cosine of a degree argument.

        Parameters:
        -----------
        x : float, numpy.ndarray
            Angle or an array of angles in degrees.

        Returns:
        --------
        s : float, numpy.ndarray
            A cosine or array of cosines of angles in degrees.

    cotand(x: Union[float, numpy.ndarray]) -> Union[float, numpy.ndarray]
        Coangent of a degree argument.

        Parameters:
        -----------
        x : float, numpy.ndarray
            Angle or an array of angles in degrees.

        Returns:
        --------
        s : float, numpy.ndarray
            A cotangent or array of cotangents of angles in degrees.

    cr3bp_fb(t: float, s: numpy.ndarray, mu: float, stm_req: bool) -> numpy.ndarray   
        Right-hand side of the circular restricted three-body problem equations of moti
on
        wrt the first primary body.

        Parameters:
        -----------
        t : float
            Time
        s : numpy.ndarray, shape (6,), (42,)
            Phase state vector containing position and velocity and (if stm_req = True)
            vectorized state-transition matrix.
            Vector structure:
            [x, y, z, vx, vy, vz] if stm_req = False
            [x, y, z, vx, vy, vz, m11, m21, m31, ...] if stm_req = True
        mu : float
            Mass parameter of the three-body system
        stm_req : bool
            Flag to calculate the derivative of the state-transition matrix

        Returns:
        --------
        f : numpy.ndarray, shape (6,), (42,)
            Gravitational acceleration according to the circular restricted
            three-body model of motion wrt the first primary body extended
            (if stm_req = True) by the derivative of the state-transition matrix.     
            Vector structure:
            [fx, fy, fz, fvx, fvy, fvz] if stm_req = False
            [fx, fy, fz, fvx, fvy, fvz, fm11, fm21, fm31, ... ] if stm_req = True     

    cr3bp_sb(t: float, s: numpy.ndarray, mu: float, stm_req: bool) -> numpy.ndarray   
        Right-hand side of the circular restricted three-body problem equations of moti
on
        wrt the secondary primary body.

        Parameters:
        -----------
        t : float
            Time
        s : numpy.ndarray, shape (6,), (42,)
            Phase state vector containing position and velocity and (if stm_req = True)
            vectorized state-transition matrix.
            Vector structure:
            [x, y, z, vx, vy, vz] if stm_req = False
            [x, y, z, vx, vy, vz, m11, m21, m31, ...] if stm_req = True
        mu : float
            Mass parameter of the three-body system
        stm_req : bool
            Flag to calculate the derivative of the state-transition matrix

        Returns:
        --------
        f : numpy.ndarray, shape (6,), (42,)
            Gravitational acceleration according to the circular restricted
            three-body model of motion wrt the secondary primary body extended        
            (if stm_req = True) by the derivative of the state-transition matrix.     
            Vector structure:
            [fx, fy, fz, fvx, fvy, fvz] if stm_req = False
            [fx, fy, fz, fvx, fvy, fvz, fm11, fm21, fm31, ... ] if stm_req = True     

    deg2rad(deg: Union[float, numpy.ndarray]) -> Union[float, numpy.ndarray]
        Degrees to radians conversion.

        Parameters:
        -----------
        deg : float, numpy.ndarray
            Angle or array of angles in degrees.

        Returns:
        --------
        rad : float, numpy.ndarray
            Angle or array of angles in radians.

        Examples:
        ---------
        deg2rad(180)
            3.141592653589793

    dotainvb(a: numpy.ndarray, b: numpy.ndarray) -> numpy.ndarray
        Calculate a*b^(-1) for matrices a and b.

        Parameters:
        -----------
        a : numpy.ndarray, shape (n, n)
            A square matrix.
        b : numpe.ndarray, shape (n, n)
            A square matrix.

        Returns:
        --------
        c : numpy.ndarray, shape (n, n)
            The matrix that equals a*b^(-1)

    ee2rv(ee: numpy.ndarray, mu: float, grad_req: bool = False) -> Union[numpy.ndarray,
 tuple[numpy.ndarray, numpy.ndarray]]
        Equinoctial orbital elements to position and velocity.

        Parameters:
        -----------
        ee : numpy.ndarray, shape (6,)
            6D vector of equinoctial orbital elements:
            h = sqrt(p/mu),
            ex = e*cos(Omega+omega),
            ey = e*sin(Omega+omega),
            ix = tan(i/2)*cos(Omega),
            iy = tan(i/2)*sin(Omega),
            L = theta + omega + Omega,
            where
            mu - gravitational parameter,
            p - semi-latus rectum (focal parameter),
            e - eccentricity,
            Omega - right ascension of the ascending node,
            omega - argument of pericenter,
            i - inclination
        mu : float
            Gravitational parameter
        grad_req : bool
            Flag to calculate the derivatives of position and velocity wrt elemets    

        Returns:
        --------
        rv : numpy.ndarray, shape (6,)
            6D phase vector containing position and velocity.
            Vector structure: [x, y, z, vx, dy, dz]
        drv : numpy.ndarray, shape (6,6)
            6x6 matrix of partial derivatives of rv wrt ee (drv/dee).
            Returns only if grad_req = True

    eyevec(n: int) -> numpy.ndarray
        Vector form of an identity matrix.

        Parameters:
        -----------
        n : int
            The number of rows and columns in the identity matrix.

        Returns:
        --------
        a : numpy.ndarray, shape (n**2,)
            Vector form of the identity matrix.

    gcrs2hcrs(xgcrs: numpy.ndarray, jd: numpy.ndarray, dist_unit: float, vel_unit: floa
t) -> numpy.ndarray
        Translate phase vectors from GCRS c/s to HCRS c/s.

        Parameters:
        -----------
        xgcrs : numpy.ndarray, shape (6,n)
            Array of 6D column phase vectors in the GCRS coordinate system
            Vector structure: [x, y, z, vx, vy, vz]
        jd : numpy.ndarray, shape (n,)
            Julian dates corresponding to columns in xgcrs
        dist_unit : float
            The unit of distance in km
        vel_unit : float
            The unit of velocity in km/s

        Returns:
        --------
        xhcrs : numpy.ndarray, shape (6,n)
            Array of 6D column phase vectors in the HCRS coordinate system
            Vector structure: [x, y, z, vx, vy, vz]

    gcrs2itrs(xgcrs: numpy.ndarray, jd: float, grad_req: bool = False) -> Union[numpy.n
darray, tuple[numpy.ndarray, numpy.ndarray]]
        Translate vector from GCRS c/s to ITRS c/s.

        Parameters:
        -----------
        xgcrs : numpy.ndarray, shape (3,)
            3D vector in the GCRS coordinate system
        jd : float
            Julian date corresponding to xgcrs
        grad_req : bool
            Flag to calculate the derivatives of the ITRS vector wrt the GCRS vector  

        Returns:
        --------
        xitrs : numpy.ndarray, shape (3,)
            3D vector in the ITRS coordinate system
        dxitrs : numpy.ndarray, shape (3,3)
            3x3 matrix of partial derivatives of xitrs wrt xgcrs (dxitrs/dxgcrs).     
            Returns only if grad_req = True

    gcrs2scrs(xgcrs: numpy.ndarray, jd: numpy.ndarray, dist_unit: float, vel_unit: floa
t) -> numpy.ndarray
        Translate phase vectors from GCRS c/s to SCRS c/s.

        Parameters:
        -----------
        xgcrs : numpy.ndarray, shape (6,n)
            Array of 6D column phase vectors in the GCRS coordinate system
            Vector structure: [x, y, z, vx, vy, vz]
        jd : numpy.ndarray, shape (n,)
            Julian dates corresponding to columns in xgcrs
        dist_unit : float
            The unit of distance in km
        vel_unit : float
            The unit of velocity in km/s

        Returns:
        --------
        xscrs : numpy.ndarray, shape (6,n)
            Array of 6D column phase vectors in the SCRS coordinate system
            Vector structure: [x, y, z, vx, vy, vz]

    get_altitude_km(period_hours: float, body: str) -> float
        Calculate the altitude of a circular orbit with a given period
        around a specified celestial body.

        Parameters:
        -----------
        period : float
            The circular orbit period in hours.
        body: str
            The name of the celesial body.

        Returns:
        --------
        altitude_km: float
            The altitude above the surface of the body in km.

    get_circular_velocity_km_s(altitude_km: float, body: str) -> float
        Calculate the circular velocity at a given altitude
        around a specified celestial body.

        Parameters:
        -----------
        altitude_km : float
            The altitude above the surface of the body in km.
        body : str
            The name of the celesial body.

        Returns:
        --------
        velocity : float
            The circular velocity at the given altitude.

    get_dv_hohmann(r1_nondim: float, r2_nondim: float) -> float
        Calculate delta-v in a Hohmann transfer.

        Parameters:
        -----------
        r1_nondim : float
            Nondimensional distance to the center of mass of the central body at the st
art.
        r2_nondim : float
            Nondimensional distance to the center of mass of the central body at the en
d.

        Returns:
        --------
        dv : float
            Nondimensional delta-v in the Hohmann transfer connecting r1_nondim and r2_
nondim.
            It is assumed that the gravitational parameter equals 1.0.

    get_order(altitude_thousands_km: float, approx_level: str = 'soft') -> int        
        The minimum order and degree of the complex lunar gravitational field
        at a given altitude according to the Trofimov--Shirobokov model.

        Parameters:
        -----------
        altitude_thousands_km : float
            The altitude above the lunar surface in km.
        approx_level : str
            The level of approximation, can be 'soft' or 'hard'.

        Returns:
        --------
        order : int
            The order and degree of the complex lunar gravitational field.

    get_period_hours(altitude_km: float, body: str) -> float
        Calculate the circular orbit period with a given altitude
        around a specified celestial body.

        Parameters:
        -----------
        altitude_km: float
            The altitude above the surface of the body in km.
        body: str
            The name of the celesial body.

        Returns:
        --------
        period : float
            The circular orbit period in hours.

    get_tof_hohmann(r1_nondim: float, r2_nondim: float) -> float
        Calculate the time of flight in a Hohmann transfer.

        Parameters:
        -----------
        r1_nondim : float
            Nondimensional distance to the center of mass of the central body at the st
art.
        r2_nondim : float
            Nondimensional distance to the center of mass of the central body at the en
d.

        Returns:
        --------
        tof : float
            Nondimensional time of flight in the Hohmann transfer connecting
            r1_nondim and r2_nondim. It is assumed that the gravitational parameter   
            equals 1.0.

    hcrs2gcrs(xhcrs: numpy.ndarray, jd: numpy.ndarray, dist_unit: float, vel_unit: floa
t) -> numpy.ndarray
        Translate phase vectors from HCRS c/s to GCRS c/s.

        Parameters:
        -----------
        xhcrs : numpy.ndarray, shape (6,n)
            Array of 6D column phase vectors in the HCRS coordinate system
            Vector structure: [x, y, z, vx, vy, vz]
        jd : numpy.ndarray, shape (n,)
            Julian dates corresponding to columns in xhcrs
        dist_unit : float
            The unit of distance in km
        vel_unit : float
            The unit of velocity in km/s

        Returns:
        --------
        xgcrs : numpy.ndarray, shape (6,n)
            Array of 6D column phase vectors in the GCRS coordinate system
            Vector structure: [x, y, z, vx, vy, vz]

    histogram(x, num_bins=None, density=False, ax=None, xlabel='', ylabel='', show=Fals
e, saveto=False)

    ine2rot(xine: numpy.ndarray, t: numpy.ndarray, t0: numpy.ndarray) -> numpy.ndarray
        Translate phase vectors from INE c/s to ROT c/s.

        Parameters:
        -----------
        xine : numpy.ndarray, shape (6,n)
            Array of 6D column phase vectors in the INE coordinate system
            Vector structure: [x, y, z, vx, vy, vz]
        t : numpy.ndarray, shape (n,)
            Times corresponding columns of xine
        t0 : numpy.ndarray, shape (1,), (n,)
            Times corresponding to coincidence of INE and ROT c/s for each column of xi
ne

        Returns:
        --------
        xrot : numpy.ndarray, shape (6,n)
            Array of 6D column phase vectors in the ROT coordinate system
            Vector structure: [x, y, z, vx, vy, vz]

    ine2rot_eph(xine: numpy.ndarray, jd: numpy.ndarray, first_body: str, secondary_body
: str, dist_unit: float, vel_unit: float) -> numpy.ndarray
        Translate phase vectors from INEEPH c/s to ROTEPH c/s.

        Parameters:
        -----------
        xine : numpy.ndarray, shape (6,n)
            Array of 6D column phase vectors in the INEEPH coordinate system
            Vector structure: [x, y, z, vx, vy, vz]
        jd : numpy.ndarray, shape (n,)
            Julian dates corresponding to columns in xine
        first_body : str
            Name of the first primary body
        secondary_body : str
            Name of the secondary primary body
        dist_unit : float
            The unit of distance in km
        vel_unit : float
            The unit of velocity in km/s

        Returns:
        --------
        xrot : numpy.ndarray, shape (6,n)
            Array of 6D column phase vectors in the ROTEPH coordinate system
            Vector structure: [x, y, z, vx, vy, vz]

    invadotb(a: numpy.ndarray, b: numpy.ndarray) -> numpy.ndarray
        Calculate a^(-1)*b for matrices a and b.

        Parameters:
        -----------
        a : numpy.ndarray, shape (n, n)
            A square matrix.
        b : numpe.ndarray, shape (n, n)
            A square matrix.

        Returns:
        --------
        c : numpy.ndarray, shape (n, n)
            The matrix that equals a^(-1)*b

    is_visible(r_sat: numpy.ndarray, lat_deg: Union[int, float, numpy.ndarray], long_de
g: Union[int, float, numpy.ndarray], body_radius: float, threshold_deg: Union[int, floa
t, numpy.ndarray]) -> tuple
        Get visibility statuses (0 or 1) of a vector from a point on a sphere surface.

        Parameters:
        -----------
        r_sat : numpy.ndarray, shape (3,), (3,n)
            Radius-vector(s) around a sphere surface
        lat_deg : int, float, numpy.ndarray, shape (m,)
            Latitude of a point(s) on a surface in degrees
        long_deg : int, float, numpy.ndarray, shape (m,)
            Longitude of a point(s) on a surface in degrees
        body_radius : float
            Body radius
        threshold_deg : int, float, numpy.ndarray, shape (n,)
            Minimum angle below which the vector is not visible.

        Returns:
        --------
        status : numpy.ndarray, shape (n,m)
            Visibility statuses of the r_sat vectors from lat_deg/long_deg points.    
            n - number of vectors in r_sat
            m - number of points on the surface
        elev_deg : numpy.ndarray, shape (n,m)
            Elevation angles in degrees
            n - number of vectors in r_sat
            m - number of points on the surface
        azim_deg : numpy.ndarray, shape (n,m)
            Azimuth angles in degrees
            n - number of vectors in r_sat
            m - number of points on the surface

    itrs2gcrs(xitrs: numpy.ndarray, jd: float, grad_req: bool = False) -> Union[numpy.n
darray, tuple[numpy.ndarray, numpy.ndarray]]
        Translate vector from ITRS c/s to GCRS c/s.

        Parameters:
        -----------
        xitrs : numpy.ndarray, shape (3,)
            3D vector in the ITRS coordinate system
        jd : float
            Julian date corresponding to xitrs
        grad_req : bool
            Flag to calculate the derivatives of the GCRS vector wrt the ITRS vector  

        Returns:
        --------
        xgcrs : numpy.ndarray, shape (3,)
            3D vector in the GCRS coordinate system
        dxgcrs : numpy.ndarray, shape (3,3)
            3x3 matrix of partial derivatives of xgcrs wrt xitrs (dxgcrs/dxitrs).     
            Returns only if grad_req = True

    jd2time(jd: float) -> datetime.datetime
        Julian date to usual date and time.

        Parameters:
        -----------
        jd : float
            Julian date

        Returns:
        --------
        time : datetime.datetime
            Date and time object of type datetime.datetime

        Examples:
        ---------
        jd2time(2459905.5)
            2022-11-22 00:00:00

    juliandate(year: int, month: int, day: int, hour: int, minute: int, second: int) ->
 float
        Usual date to Julian date.

        Parameters:
        -----------
        year : int
            Year
        month : int
            Month
        day : int
            Day
        hour : int
            Hour
        minute : int
            Minute
        second : int
            Second

        Returns:
        --------
        jd : float
            Julian date

        Examples:
        ---------
        juliandate(2022, 11, 22, 0, 0, 0)
            2459905.5

    latlon2cart(latlon: numpy.ndarray) -> numpy.ndarray
        Latitude and longitude to Cartesian coordinates.

        Parameters:
        -----------
        latlon : numpy.ndarray, shape (2,), (2, n)
            2D Vector or array of column 2D vectors of latitude and longitude pairs.  
            Vector structure: [lat, lon], where
            lat in [-pi/2, pi/2],
            lon in [-pi, pi]

        Returns:
        --------
        cart : numpy.ndarray, shape (3,), (3, n)
            3D vector or array of column 3D vectors of Cartesian coordinates
            Vector structure: [x, y, z]

    load(filename: str) -> Any
        Loads a variable from a specified file.

        Parameters:
        -----------
        filename : str
            A path to the file.

    lvlh2mer(xlvlh: numpy.ndarray, lat: float, lon: float) -> numpy.ndarray
        Translate phase vector(s) from LVLH c/s to MER c/s.

        Parameters:
        -----------
        xlvlh : numpy.ndarray, shape (3,), (3,n)
            3D vector or array of 3D column phase vectors in the LVLH coordinate system
        lat : float
            Latitude that specifies the LVLH c/s
        lon : float
            Longitude that specifies the LVLH c/s

        Returns:
        --------
        xmer : numpy.ndarray, shape (3,), (3,n)
            3D vector or array of 3D column phase vectors in the MER coordinate system

    mer2lvlh(xmer: numpy.ndarray, lat: float, lon: float) -> numpy.ndarray
        Translate phase vector(s) from MER c/s to LVLH c/s.

        Parameters:
        -----------
        xmer : numpy.ndarray, shape (3,), (3,n)
            3D vector or array of 3D column phase vectors in the MER coordinate system
        lat : float
            Latitude that specifies the LVLH c/s
        lon : float
            Longitude that specifies the LVLH c/s

        Returns:
        --------
        xlvlh : numpy.ndarray, shape (3,), (3,n)
            3D vector or array of 3D column phase vectors in the LVLH coordinate system

    mer2scrs(xmer: numpy.ndarray, jd: numpy.ndarray, grad_req: bool = False) -> Union[n
umpy.ndarray, tuple[numpy.ndarray, numpy.ndarray]]
        Translate vectors from MER c/s to SCRS c/s.

        Parameters:
        -----------
        xmer : numpy.ndarray, shape (3,n), (6,n)
            Array of 3D or 6D column vectors in the MER coordinate system
        jd : numpy.ndarray, shape (n,)
            Julian dates corresponding to columns in xmer
        grad_req : bool
            Flag to calculate the derivatives of the SCRS vector wrt the MER vector   

        Returns:
        --------
        xscrs : numpy.ndarray, shape (3,n), (6,n)
            Array of 6D column vectors in the SCRS coordinate system
        dxscrs : numpy.ndarray, shape (3,3,n), (6,6,n)
            Array of matrices of partial derivatives of xscrs wrt xmer (dxscrs/dxmer).
            Returns only if grad_req = True

    nbp_ee_earth(t: float, s: numpy.ndarray, stm_req: bool, sources: dict, data: dict, 
units_data: dict) -> numpy.ndarray
        Right-hand side of the n-body problem equations of motion wrt the Earth in term
s of
        the equinoctial orbital elements.

        Parameters:
        -----------
        t : float
            Time
        s : numpy.ndarray, shape (6,), (42,)
            Phase state vector containing equinoctial elements and (if stm_req = True)
            vectorized state-transition matrix.
            Vector structure:
            [h, ex, ey, ix, iy, L] if stm_req = False,
            [h, ex, ey, ix, iy, L, m11, m21, m31, ...] if stm_req = True,
            h = sqrt(p/mu),
            ex = e*cos(Omega+omega),
            ey = e*sin(Omega+omega),
            ix = tan(i/2)*cos(Omega),
            iy = tan(i/2)*sin(Omega),
            L = theta + omega + Omega,
            where
            mu - gravitational parameter,
            p - semi-latus rectum (focal parameter),
            e - eccentricity,
            Omega - right ascension of the ascending node,
            omega - argument of pericenter,
            i - inclination
        stm_req : bool
            Flag to calculate the derivative of the state-transition matrix
        sources : dict
            Dictionary that contains the perturbations that should be accounted.      
            The dictionary keys:
            'atm'       (Earth's atmosphere)
            'j2'        (Earth's J2)
            'srp'       (Solar radiation pressure)
            'sun'       (Gravitational acceleration of the Sun)
            'mercury'   (Gravitational acceleration of Mercury)
            'venus'     (Gravitational acceleration of Venus)
            'earth'     (Gravitational acceleration of the Earth)
            'mars'      (Gravitational acceleration of Mars)
            'jupiter'   (Gravitational acceleration of Jupiter)
            'saturn'    (Gravitational acceleration of Saturn)
            'uranus'    (Gravitational acceleration of Uranus)
            'neptune'   (Gravitational acceleration of Neptune)
            'moon'      (Gravitational acceleration of the Moon)
            'cmplxmoon' (Complex gravitational acceleration of the Moon)
            If sources[key] = True, the corresponding perturbation will be accounted. 
            If sources[key] = False, the corresponding perturbation will not be account
ed.
            The sources dictionary with all False values can be created by
            the kiam.prepare_sources_dict() function.
        data : dict
            A dictionary that contains auxilary data.
            The dictionary keys:
            'jd_zero' (Julian date that corresponds to t = 0)
            'order'   (Order of the lunar complex gravitational field)
            'area'    (Area of the spacecraft to account in atmospheric drag and SRP, m
^2)
            'mass'    (Mass of the spacecraft to account in atmospheric drag and SRP, k
g)
            The data should be submitted even if the corresponding perturbations      
            are not accounted.
        units_data : dict
            A dictionary that contains the units.
            The dictionary keys:
            'DistUnit' (The unit of distance in km)
            'VelUnit'  (The unit of velocity in km/s)
            'TimeUnit' (The unit of time in days)
            'AccUnit'  (The unit of acceleration in m/s^2)
            'RSun'     (The radius of the Sun in the units of distance)
            'REarth'   (The radius of the Earth in the units of distance)
            'RMoon'    (The radius of the Moon in the units of distance)

        Returns:
        --------
        f : numpy.ndarray, shape (6,), (42,)
            Phase state time dericatives according to the specified n-body problem equa
tions
            of motion extended (if stm_req = True) by the derivative of the
            state-transition matrix.
            Vector structure:
            [fh, fex, fey, fix, fiy, fL] if stm_req = False
            [fh, fex, fey, fix, fiy, fL, fm11, fm21, fm31, ... ] if stm_req = True    

    nbp_ee_moon(t: float, s: numpy.ndarray, stm_req: bool, sources: dict, data: dict, u
nits_data: dict) -> numpy.ndarray
        Right-hand side of the n-body problem equations of motion wrt the Moon in terms
 of
        the equinoctial orbital elements.

        Parameters:
        -----------
        t : float
            Time
        s : numpy.ndarray, shape (6,), (42,)
            Phase state vector containing equinoctial elements and (if stm_req = True)
            vectorized state-transition matrix.
            Vector structure:
            [h, ex, ey, ix, iy, L] if stm_req = False,
            [h, ex, ey, ix, iy, L, m11, m21, m31, ...] if stm_req = True,
            h = sqrt(p/mu),
            ex = e*cos(Omega+omega),
            ey = e*sin(Omega+omega),
            ix = tan(i/2)*cos(Omega),
            iy = tan(i/2)*sin(Omega),
            L = theta + omega + Omega,
            where
            mu - gravitational parameter,
            p - semi-latus rectum (focal parameter),
            e - eccentricity,
            Omega - right ascension of the ascending node,
            omega - argument of pericenter,
            i - inclination
        stm_req : bool
            Flag to calculate the derivative of the state-transition matrix
        sources : dict
            Dictionary that contains the perturbations that should be accounted.      
            The dictionary keys:
            'atm'       (Earth's atmosphere)
            'j2'        (Earth's J2)
            'srp'       (Solar radiation pressure)
            'sun'       (Gravitational acceleration of the Sun)
            'mercury'   (Gravitational acceleration of Mercury)
            'venus'     (Gravitational acceleration of Venus)
            'earth'     (Gravitational acceleration of the Earth)
            'mars'      (Gravitational acceleration of Mars)
            'jupiter'   (Gravitational acceleration of Jupiter)
            'saturn'    (Gravitational acceleration of Saturn)
            'uranus'    (Gravitational acceleration of Uranus)
            'neptune'   (Gravitational acceleration of Neptune)
            'moon'      (Gravitational acceleration of the Moon)
            'cmplxmoon' (Complex gravitational acceleration of the Moon)
            If sources[key] = True, the corresponding perturbation will be accounted. 
            If sources[key] = False, the corresponding perturbation will not be account
ed.
            The sources dictionary with all False values can be created by
            the kiam.prepare_sources_dict() function.
        data : dict
            A dictionary that contains auxilary data.
            The dictionary keys:
            'jd_zero' (Julian date that corresponds to t = 0)
            'order'   (Order of the lunar complex gravitational field)
            'area'    (Area of the spacecraft to account in atmospheric drag and SRP, m
^2)
            'mass'    (Mass of the spacecraft to account in atmospheric drag and SRP, k
g)
            The data should be submitted even if the corresponding perturbations      
            are not accounted.
        units_data : dict
            A dictionary that contains the units.
            The dictionary keys:
            'DistUnit' (The unit of distance in km)
            'VelUnit'  (The unit of velocity in km/s)
            'TimeUnit' (The unit of time in days)
            'AccUnit'  (The unit of acceleration in m/s^2)
            'RSun'     (The radius of the Sun in the units of distance)
            'REarth'   (The radius of the Earth in the units of distance)
            'RMoon'    (The radius of the Moon in the units of distance)

        Returns:
        --------
        f : numpy.ndarray, shape (6,), (42,)
            Phase state time dericatives according to the specified n-body problem equa
tions
            of motion extended (if stm_req = True) by the derivative of the
            state-transition matrix.
            Vector structure:
            [fh, fex, fey, fix, fiy, fL] if stm_req = False
            [fh, fex, fey, fix, fiy, fL, fm11, fm21, fm31, ... ] if stm_req = True    

    nbp_rv_earth(t: float, s: numpy.ndarray, stm_req: bool, sources: dict, data: dict, 
units_data: dict) -> numpy.ndarray
        Right-hand side of the n-body problem equations of motion wrt the Earth in term
s of
        the position and velocity variables.

        Parameters:
        -----------
        t : float
            Time
        s : numpy.ndarray, shape (6,), (42,)
            Phase state vector containing position and velocity and (if stm_req = True)
            vectorized state-transition matrix.
            Vector structure:
            [x, y, z, vx, vy, vz] if stm_req = False
            [x, y, z, vx, vy, vz, m11, m21, m31, ...] if stm_req = True
        stm_req : bool
            Flag to calculate the derivative of the state-transition matrix
        sources : dict
            Dictionary that contains the perturbations that should be accounted.      
            The dictionary keys:
            'atm'       (Earth's atmosphere)
            'j2'        (Earth's J2)
            'srp'       (Solar radiation pressure)
            'sun'       (Gravitational acceleration of the Sun)
            'mercury'   (Gravitational acceleration of Mercury)
            'venus'     (Gravitational acceleration of Venus)
            'earth'     (Gravitational acceleration of the Earth)
            'mars'      (Gravitational acceleration of Mars)
            'jupiter'   (Gravitational acceleration of Jupiter)
            'saturn'    (Gravitational acceleration of Saturn)
            'uranus'    (Gravitational acceleration of Uranus)
            'neptune'   (Gravitational acceleration of Neptune)
            'moon'      (Gravitational acceleration of the Moon)
            'cmplxmoon' (Complex gravitational acceleration of the Moon)
            If sources[key] = True, the corresponding perturbation will be accounted. 
            If sources[key] = False, the corresponding perturbation will not be account
ed.
            The sources dictionary with all False values can be created by
            the kiam.prepare_sources_dict() function.
        data : dict
            A dictionary that contains auxilary data.
            The dictionary keys:
            'jd_zero' (Julian date that corresponds to t = 0)
            'order'   (Order of the lunar complex gravitational field)
            'area'    (Area of the spacecraft to account in atmospheric drag and SRP, m
^2)
            'mass'    (Mass of the spacecraft to account in atmospheric drag and SRP, k
g)
            The data should be submitted even if the corresponding perturbations      
            are not accounted.
        units_data : dict
            A dictionary that contains the units.
            The dictionary keys:
            'DistUnit' (The unit of distance in km)
            'VelUnit'  (The unit of velocity in km/s)
            'TimeUnit' (The unit of time in days)
            'AccUnit'  (The unit of acceleration in m/s^2)
            'RSun'     (The radius of the Sun in the units of distance)
            'REarth'   (The radius of the Earth in the units of distance)
            'RMoon'    (The radius of the Moon in the units of distance)

        Returns:
        --------
        f : numpy.ndarray, shape (6,), (42,)
            Gravitational acceleration according to the specified n-body problem equati
ons
            of motion extended (if stm_req = True) by the derivative of the
            state-transition matrix.
            Vector structure:
            [fx, fy, fz, fvx, fvy, fvz] if stm_req = False
            [fx, fy, fz, fvx, fvy, fvz, fm11, fm21, fm31, ... ] if stm_req = True     

    nbp_rv_moon(t: float, s: numpy.ndarray, stm_req: bool, sources: dict, data: dict, u
nits_data: dict) -> numpy.ndarray
        Right-hand side of the n-body problem equations of motion wrt the Moon in terms
 of
        the position and velocity variables.

        Parameters:
        -----------
        t : float
            Time
        s : numpy.ndarray, shape (6,), (42,)
            Phase state vector containing position and velocity and (if stm_req = True)
            vectorized state-transition matrix.
            Vector structure:
            [x, y, z, vx, vy, vz] if stm_req = False
            [x, y, z, vx, vy, vz, m11, m21, m31, ...] if stm_req = True
        stm_req : bool
            Flag to calculate the derivative of the state-transition matrix
        sources : dict
            Dictionary that contains the perturbations that should be accounted.      
            The dictionary keys:
            'atm'       (Earth's atmosphere)
            'j2'        (Earth's J2)
            'srp'       (Solar radiation pressure)
            'sun'       (Gravitational acceleration of the Sun)
            'mercury'   (Gravitational acceleration of Mercury)
            'venus'     (Gravitational acceleration of Venus)
            'earth'     (Gravitational acceleration of the Earth)
            'mars'      (Gravitational acceleration of Mars)
            'jupiter'   (Gravitational acceleration of Jupiter)
            'saturn'    (Gravitational acceleration of Saturn)
            'uranus'    (Gravitational acceleration of Uranus)
            'neptune'   (Gravitational acceleration of Neptune)
            'moon'      (Gravitational acceleration of the Moon)
            'cmplxmoon' (Complex gravitational acceleration of the Moon)
            If sources[key] = True, the corresponding perturbation will be accounted. 
            If sources[key] = False, the corresponding perturbation will not be account
ed.
            The sources dictionary with all False values can be created by
            the kiam.prepare_sources_dict() function.
        data : dict
            A dictionary that contains auxilary data.
            The dictionary keys:
            'jd_zero' (Julian date that corresponds to t = 0)
            'order'   (Order of the lunar complex gravitational field)
            'area'    (Area of the spacecraft to account in atmospheric drag and SRP, m
^2)
            'mass'    (Mass of the spacecraft to account in atmospheric drag and SRP, k
g)
            The data should be submitted even if the corresponding perturbations      
            are not accounted.
        units_data : dict
            A dictionary that contains the units.
            The dictionary keys:
            'DistUnit' (The unit of distance in km)
            'VelUnit'  (The unit of velocity in km/s)
            'TimeUnit' (The unit of time in days)
            'AccUnit'  (The unit of acceleration in m/s^2)
            'RSun'     (The radius of the Sun in the units of distance)
            'REarth'   (The radius of the Earth in the units of distance)
            'RMoon'    (The radius of the Moon in the units of distance)

        Returns:
        --------
        f : numpy.ndarray, shape (6,), (42,)
            Gravitational acceleration according to the specified n-body problem equati
ons
            of motion extended (if stm_req = True) by the derivative of the
            state-transition matrix.
            Vector structure:
            [fx, fy, fz, fvx, fvy, fvz] if stm_req = False
            [fx, fy, fz, fvx, fvy, fvz, fm11, fm21, fm31, ... ] if stm_req = True     

    oe2rv(oe: numpy.ndarray, mu: float, grad_req: bool = False) -> Union[numpy.ndarray,
 tuple[numpy.ndarray, numpy.ndarray]]
        Classical orbital elements to position and velocity.

        Parameters:
        -----------
        oe : numpy.ndarray, shape (6,)
            6D vector of classical orbital elements:
            a (semi-major axis),
            e (eccentricity),
            i (inclination),
            Omega (right ascension of the ascending node),
            omega (argument of pericenter),
            theta (true anomaly)
        mu : float
            Gravitational parameter
        grad_req : bool
            Flag to calculate the derivatives of position and velocity wrt elements   

        Returns:
        --------
        rv : numpy.ndarray, shape (6,)
            6D phase vector containing position and velocity.
            Vector structure: [x, y, z, vx, dy, dz]
        drv : numpy.ndarray, shape (6,6)
            6x6 matrix of partial derivatives of rv wrt oe (drv/doe)
            Returns only if grad_req = True

    planet_state(jd: float, center: str, target: str) -> numpy.ndarray
        Gives position and velocity of the planet at specified julian date
        wrt to the specified center (planet).

        Parameters:
        -----------
        jd : float
            Julian date
        center : str
            Name of the center planet
        target : str
            Name of the target planet

        Returns:
        --------
        state : numpy.ndarray, shape(6,)
            State of the target planet wrt the center planet.
            Position in km, velocity in km/s.

    plot(x, y, ax=None, style='-', xlabel='', ylabel='', linewidth=1.0, show=False, sav
eto=False)
        # Plotting functions (not documented, will be rewritten)

    plot3(x, y, z, ax=None, style='-', xlabel='', ylabel='', zlabel='', linewidth=1.0, 
show=False, saveto=False)

    polar_plot(phi, r, ax=None, rmax=None, style='-', linewidth=1.0, show=False, saveto
=False)

    prepare_sources_dict() -> dict
        Auxilary function that returns a dictionary of perturbations.

        Returns:
        --------
        sources : dict
        The dictionary keys:
        'atm'       (Earth's atmosphere)
        'j2'        (Earth's J2)
        'srp'       (Solar radiation pressure)
        'sun'       (Gravitational acceleration of the Sun)
        'mercury'   (Gravitational acceleration of Mercury)
        'venus'     (Gravitational acceleration of Venus)
        'earth'     (Gravitational acceleration of the Earth)
        'mars'      (Gravitational acceleration of Mars)
        'jupiter'   (Gravitational acceleration of Jupiter)
        'saturn'    (Gravitational acceleration of Saturn)
        'uranus'    (Gravitational acceleration of Uranus)
        'neptune'   (Gravitational acceleration of Neptune)
        'moon'      (Gravitational acceleration of the Moon)
        'cmplxmoon' (Complex gravitational acceleration of the Moon)

    propagate_br4bp(central_body: str, tspan: numpy.ndarray, x0: numpy.ndarray, mu: flo
at, gm4b, a4b: float, theta0: float, stm: bool) -> tuple
        Propagate trajectory in the bi-circular restricted four-body model of motion. 

        Parameters:
        -----------
        central_body : str
            First or secondary primary body as the central body
        tspan: numpy.ndarray, shape (n,)
            Time nodes at which the solution is required
        x0 : numpy.ndarray, shape (6,), (42,)
            Initial state containing:
            position and velocity (if stm = False),
            position and velocoty extended by vectorized state-transition matrix (if st
m = True),
            Vectory structure:
            [x, y, z, vx, vy, vz] if stm = False
            [x, y, z, vx, vy, vz, m11, m21, m31, ...] if stm = True
        mu : float
            Mass parameter of the three-body system
        gm4b : float
            Scaled gravitational parameter of the fourth (perturbing) body
        a4b : float
            Distance from the center of mass of the primary bodies to the fourth body 
            in units where the distance between the primaries equals 1.
        theta0 : float
            Initial value of the synodic phase - the angle between the direction to   
            the fourth body from the center of mass of the primaries and the line     
            connecting the primaties
        stm : bool
            Flag to calculate the derivative of the state-transition matrix

        Returns:
        --------
        t : numpy.ndarray, shape(n,)
            Times (nodes) in tspan at which the solution is obtained
        y : numpy.ndarray, shape(6, n)
            Array of column trajectory phase states.
            Vector structure:
            [x, y, z, vx, vy, vz] if stm = False
            [x, y, z, vx, vy, vz, m11, m21, m31, ...] if stm = True

    propagate_cr3bp(central_body: str, tspan: numpy.ndarray, x0: numpy.ndarray, mu: flo
at, stm: bool) -> tuple
        Propagate trajectory in the circular restricted three-body model of motion.   

        Parameters:
        -----------
        central_body : str
            First or secondary primary body as the central body
        tspan: numpy.ndarray, shape (n,)
            Time nodes at which the solution is required
        x0 : numpy.ndarray, shape (6,), (42,)
            Initial state containing:
            position and velocity (if stm = False),
            position and velocoty extended by vectorized state-transition matrix (if st
m = True),
            Vectory structure:
            [x, y, z, vx, vy, vz] if stm = False
            [x, y, z, vx, vy, vz, m11, m21, m31, ...] if stm = True
        mu : float
            Mass parameter of the three-body system
        stm : bool
            Flag to calculate the derivative of the state-transition matrix

        Returns:
        --------
        t : numpy.ndarray, shape(n,)
            Times (nodes) in tspan at which the solution is obtained
        y : numpy.ndarray, shape(6, n)
            Array of column trajectory phase states.
            Vector structure:
            [x, y, z, vx, vy, vz] if stm = False
            [x, y, z, vx, vy, vz, m11, m21, m31, ...] if stm = True

    propagate_nbp(central_body: str, tspan: numpy.ndarray, x0: numpy.ndarray, sources_d
ict: dict, dat_dict: dict, stm: bool, variables: str) -> tuple
        Propagate trajectory in the n-body model of motion.

        Parameters:
        -----------
        central_body: str
            Name of the central body
        tspan: numpy.ndarray, shape (n,)
            Time nodes at which the solution is required
        x0: numpy.ndarray, shape (6,), (42,)
            Initial state containing:
            position and velocity (if variables = 'rv', stm = False),
            position and velocoty extended by vectorized state-transition matrix (if va
riables = 'rv_stm', stm = True),
            equinoctial orbital elements (if variables = 'ee', stm = False),
            equinoctial orbital elements extended by vectorized state-transition matrix
 (if variables = 'ee_stm', stm = True),
            Vectory structure:
            [x, y, z, vx, vy, vz] if variables = 'rv' and stm = False
            [x, y, z, vx, vy, vz, m11, m21, m31, ...] if variables = 'rv_stm' and stm =
 True
            [h, ex, ey, ix, iy, L] if variables = 'ee' and stm = False
            [h, ex, ey, ix, iy, L, m11, m21, m31, ...] if variables = 'ee_stm' and stm 
= True
            h = sqrt(p/mu),
            ex = e*cos(Omega+omega),
            ey = e*sin(Omega+omega),
            ix = tan(i/2)*cos(Omega),
            iy = tan(i/2)*sin(Omega),
            L = theta + omega + Omega,
            where
            mu - gravitational parameter,
            p - semi-latus rectum (focal parameter),
            e - eccentricity,
            Omega - right ascension of the ascending node,
            omega - argument of pericenter,
            i - inclination
        sources_dict: dict
            Dictionary that contains the perturbations that should be accounted.      
            The dictionary keys:
            'atm'       (Earth's atmosphere)
            'j2'        (Earth's J2)
            'srp'       (Solar radiation pressure)
            'sun'       (Gravitational acceleration of the Sun)
            'mercury'   (Gravitational acceleration of Mercury)
            'venus'     (Gravitational acceleration of Venus)
            'earth'     (Gravitational acceleration of the Earth)
            'mars'      (Gravitational acceleration of Mars)
            'jupiter'   (Gravitational acceleration of Jupiter)
            'saturn'    (Gravitational acceleration of Saturn)
            'uranus'    (Gravitational acceleration of Uranus)
            'neptune'   (Gravitational acceleration of Neptune)
            'moon'      (Gravitational acceleration of the Moon)
            'cmplxmoon' (Complex gravitational acceleration of the Moon)
            If sources[key] = True, the corresponding perturbation will be accounted. 
            If sources[key] = False, the corresponding perturbation will not be account
ed.
            The sources dictionary with all False values can be created by
            the kiam.prepare_sources_dict() function.
        dat_dict: dict
            A dictionary that contains auxilary data.
            The dictionary keys:
            'jd_zero' (Julian date that corresponds to t = 0)
            'order'   (Order of the lunar complex gravitational field)
            'area'    (Area of the spacecraft to account in atmospheric drag and SRP, m
^2)
            'mass'    (Mass of the spacecraft to account in atmospheric drag and SRP, k
g)
            The data should be submitted even if the corresponding perturbations      
            are not accounted.
        stm: bool
            Flag to calculate the derivative of the state-transition matrix
        variables: str
            Type of variables used to propagate the trajectory.
            If stm = False, then variables should be 'rv' or 'ee'
            If stm = True, then variables should be 'rv_stm' or 'ee_stm'

        Returns:
        --------
        t : numpy.ndarray, shape(n,)
            Times (nodes) in tspan at which the solution is obtained
        y : numpy.ndarray, shape(6, n), shape(42, n)
            Array of column trajectory phase states extended (if stm = True) by       
            vectorized state-transition matrices.
            Vector structure:
            [x, y, z, vx, vy, vz] if stm = False and variables = 'rv'
            [x, y, z, vx, vy, vz, m11, m21, m31, ... ] if stm = True and variables = 'r
v_stm'
            [h, ex, ey, ix, iy, L] if stm = False and variables = 'ee'
            [h, ex, ey, ix, iy, L, m11, m21, m31, ... ] if stm = True and variables = '
ee_stm'
            h = sqrt(p/mu),
            ex = e*cos(Omega+omega),
            ey = e*sin(Omega+omega),
            ix = tan(i/2)*cos(Omega),
            iy = tan(i/2)*sin(Omega),
            L = theta + omega + Omega,
            where
            mu - gravitational parameter,
            p - semi-latus rectum (focal parameter),
            e - eccentricity,
            Omega - right ascension of the ascending node,
            omega - argument of pericenter,
            i - inclination

    propagate_r2bp(tspan: numpy.ndarray, x0: numpy.ndarray) -> tuple
        Propagate trajectory in the two-body model of motion.

        Parameters:
        -----------
        tspan: numpy.ndarray, shape (n,)
            Time nodes at which the solution is required
        x0: numpy.ndarray, shape (6,)
            Initial state containing position and velocity
            Vector structure: [x, y, z, vx, vy, vz]

        Returns:
        --------
        t : numpy.ndarray, shape(n,)
            Times (nodes) in tspan at which the solution is obtained
        y : numpy.ndarray, shape(6, n)
            Array of column trajectory phase states.
            Vector structure:
            [x, y, z, vx, vy, vz]

    r2bp(t: float, s: numpy.ndarray) -> numpy.ndarray
        Right-hand side of the restricted two-body problem equations of motion.       

        Parameters:
        -----------
        t : float
            Time
        s : numpy.ndarray, shape (6,)
            Phase state vector containing position and velocity.
            Vector structure [x, y, z, vx, vy, vz]

        Returns:
        --------
        f : numpy.ndarray, shape (6,)
            Gravity acceleration according to the two-body model.
            Vector structure [fx, fy, fz, fvx, fvy, fvz]

    rad2deg(rad: Union[float, numpy.ndarray]) -> Union[float, numpy.ndarray]
        Radians to degrees conversion.

        Parameters:
        -----------
        rad : float, numpy.ndarray
            Angle or array of angles in radians.

        Returns:
        --------
        deg : float, numpy.ndarray
            Angle or array of angles in degrees.

        Examples:
        ---------
        rad2deg(3.141592)
            179.99996255206332

    rot2ine(xrot: numpy.ndarray, t: numpy.ndarray, t0: numpy.ndarray) -> numpy.ndarray
        Translate phase vectors from ROT c/s to INE c/s.

        Parameters:
        -----------
        xrot : numpy.ndarray, shape (6,n)
            Array of 6D column phase vectors in the ROT coordinate system
            Vector structure: [x, y, z, vx, vy, vz]
        t : numpy.ndarray, shape (n,)
            Times corresponding columns of xrot
        t0 : numpy.ndarray, shape (1,), (n,)
            Times corresponding to coincidence of INE and ROT c/s for each column of xr
ot

        Returns:
        --------
        xine : numpy.ndarray, shape (6,n)
            Array of 6D column phase vectors in the INE coordinate system
            Vector structure: [x, y, z, vx, vy, vz]

    rot2ine_eph(xrot: numpy.ndarray, jd: numpy.ndarray, first_body: str, secondary_body
: str, dist_unit: float, vel_unit: float) -> numpy.ndarray
        Translate phase vectors from ROTEPH c/s to INEEPH c/s.

        Parameters:
        -----------
        xrot : numpy.ndarray, shape (6,n)
            Array of 6D column phase vectors in the ROTEPH coordinate system
            Vector structure: [x, y, z, vx, vy, vz]
        jd : numpy.ndarray, shape (n,)
            Julian dates corresponding to columns in xrot
        first_body : str
            Name of the first primary body
        secondary_body : str
            Name of the secondary primary body
        dist_unit : float
            The unit of distance in km
        vel_unit : float
            The unit of velocity in km/s

        Returns:
        --------
        xine : numpy.ndarray, shape (6,n)
            Array of 6D column phase vectors in the INEEPH coordinate system
            Vector structure: [x, y, z, vx, vy, vz]

    rv2ee(rv: numpy.ndarray, mu: float, grad_req: bool = False) -> Union[numpy.ndarray,
 tuple[numpy.ndarray, numpy.ndarray]]
        Position and velocity to equinoctial orbital elements.

        Parameters:
        -----------
        rv : numpy.ndarray, shape (6,)
            6D phase vector containing position and velocity.
            Vector structure: [x, y, z, vx, dy, dz]
        mu : float
            Gravitational parameter
        grad_req : bool
            Flag to calculate the derivatives of elements wrt position and velocity   

        Returns:
        --------
        ee : numpy.ndarray, shape (6,)
            6D vector of equinoctial orbital elements:
            h = sqrt(p/mu),
            ex = e*cos(Omega+omega),
            ey = e*sin(Omega+omega),
            ix = tan(i/2)*cos(Omega),
            iy = tan(i/2)*sin(Omega),
            L = theta + omega + Omega,
            where
            mu - gravitational parameter,
            p - semi-latus rectum (focal parameter),
            e - eccentricity,
            Omega - right ascension of the ascending node,
            omega - argument of pericenter,
            i - inclination
        dee : numpy.ndarray, shape (6,6)
            6x6 matrix of partial derivatives of ee wrt rv (dee/drv).
            Returns only if grad_req = True

    rv2oe(rv: numpy.ndarray, mu: float, grad_req: bool = False) -> Union[numpy.ndarray,
 tuple[numpy.ndarray, numpy.ndarray]]
        Position and velocity to classical orbital elements.

        Parameters:
        -----------
        rv : numpy.ndarray, shape (6,)
            6D phase vector containing position and velocity.
            Vector structure: [x, y, z, vx, dy, dz]
        mu : float
            Gravitational parameter
        grad_req : bool
            Flag to calculate the derivatives of elements wrt position and velocity   

        Returns:
        --------
        oe : numpy.ndarray, shape (6,)
            6D vector of classical orbital elements:
            a (semi-major axis),
            e (eccentricity),
            i (inclination),
            Omega (right ascension of the ascending node),
            omega (argument of pericenter),
            theta (true anomaly)
        doe : numpy.ndarray, shape (6,6)
            6x6 matrix of partial derivatives of oe wrt rv (doe/drv)
            Returns only if grad_req = True

    save(variable: str, filename: str) -> None
        Saves a variable into a specified file.

        Parameters:
        -----------
        variable : str
            Variable to be saved.
            For limitations on variables see the pickle package
            https://docs.python.org/3/library/pickle.html
        filename : str
            A path to the file.

    save_plot(saveto)

    scrs2gcrs(xscrs: numpy.ndarray, jd: numpy.ndarray, dist_unit: float, vel_unit: floa
t) -> numpy.ndarray
        Translate phase vectors from SCRS c/s to GCRS c/s.

        Parameters:
        -----------
        xscrs : numpy.ndarray, shape (6,n)
            Array of 6D column phase vectors in the SCRS coordinate system
            Vector structure: [x, y, z, vx, vy, vz]
        jd : numpy.ndarray, shape (n,)
            Julian dates corresponding to columns in xscrs
        dist_unit : float
            The unit of distance in km
        vel_unit : float
            The unit of velocity in km/s

        Returns:
        --------
        xgcrs : numpy.ndarray, shape (6,n)
            Array of 6D column phase vectors in the GCRS coordinate system
            Vector structure: [x, y, z, vx, vy, vz]

    scrs2mer(xscrs: numpy.ndarray, jd: numpy.ndarray, grad_req: bool = False) -> Union[
numpy.ndarray, tuple[numpy.ndarray, numpy.ndarray]]
        Translate vectors from SCRS c/s to MER c/s.

        Parameters:
        -----------
        xscrs : numpy.ndarray, shape (3,n), (6,n)
            Array of 3D or 6D column vectors in the SCRS coordinate system
        jd : numpy.ndarray, shape (n,)
            Julian dates corresponding to columns in xscrs
        grad_req : bool
            Flag to calculate the derivatives of the MER vector wrt the SCRS vector   

        Returns:
        --------
        xmer : numpy.ndarray, shape (3,n), (6,n)
            Array of 3D or 6D column vectors in the MER coordinate system.
        dxmer : numpy.ndarray, shape (3,3,n), (6,6,n)
            Array of matrices of partial derivatives of xmer wrt xscrs (dxmer/dxscrs).
            Returns only if grad_req = True

    scrs2pa(xscrs: numpy.ndarray, jd: float, grad_req: bool = False) -> Union[numpy.nda
rray, tuple[numpy.ndarray, numpy.ndarray]]
        Translate vector from SCRS c/s to PA c/s.

        Parameters:
        -----------
        xscrs : numpy.ndarray, shape (3,)
            3D phase vector in the SCRS coordinate system
        jd : float
            Julian date corresponding to xscrs
        grad_req : bool
            Flag to calculate the derivatives of the PA vector wrt the SCRS vector    

        Returns:
        --------
        xpa : numpy.ndarray, shape (3,)
            3D phase vector in the PA coordinate system
        dxpa : numpy.ndarray, shape (3,3)
            3x3 matrix of partial derivatives of xpa wrt xscrs (dxpa/dxscrs).
            Returns only if grad_req = True

    scrs2sors(xscrs: numpy.ndarray, jd: numpy.ndarray, grad_req: bool = False) -> Union
[numpy.ndarray, tuple[numpy.ndarray, numpy.ndarray]]
        Translate vectors from SCRS c/s to SORS c/s.

        Parameters:
        -----------
        xscrs : numpy.ndarray, shape (3,n), (6,n)
            Array of 3D or 6D column vectors in the SCRS coordinate system
        jd : numpy.ndarray, shape (n,)
            Julian dates corresponding to columns in xscrs
        grad_req : bool
            Flag to calculate the derivatives of the SORS vector wrt the SCRS vector  

        Returns:
        --------
        xsors : numpy.ndarray, shape (3,n), (6,n)
            Array of 3D or 6D column vectors in the SORS coordinate system
        dxsors : numpy.ndarray, shape (3,3,n), (6,6,n)
            Array of matrices of partial derivatives of xsors wrt xscrs (dxsors/dxscrs)
.
            Returns only if grad_req = True

    sind(x: Union[float, numpy.ndarray]) -> Union[float, numpy.ndarray]
        Sine of a degree argument.

        Parameters:
        -----------
        x : float, numpy.ndarray
            Angle or an array of angles in degrees.

        Returns:
        --------
        s : float, numpy.ndarray
            A sine or array of sines of angles in degrees.

    sors2scrs(xsors: numpy.ndarray, jd: numpy.ndarray, grad_req: bool = False) -> Union
[numpy.ndarray, tuple[numpy.ndarray, numpy.ndarray]]
        Translate vectors from SORS c/s to SCRS c/s.

        Parameters:
        -----------
        xsors : numpy.ndarray, shape (3,n), (6,n)
            Array of 3D or 6D column vectors in the SORS coordinate system
        jd : numpy.ndarray, shape (n,)
            Julian dates corresponding to columns in xsors
        grad_req : bool
            Flag to calculate the derivatives of the SCRS vector wrt the SORS vector  

        Returns:
        --------
        xscrs : numpy.ndarray, shape (3,n), (6,n)
            Array of 3D or 6D column vectors in the SCRS coordinate system
        dxscrs : numpy.ndarray, shape (3,3,n), (6,6,n)
            Array of matrices of partial derivatives of xscrs wrt xsors (dxscrs/dxsors)
.
            Returns only if grad_req = True

    sphere2cart(sphere: numpy.ndarray) -> numpy.ndarray
        Spherical coordinates to Cartesian coordinates.

        Parameters:
        -----------
        sphere : numpy.ndarray, shape (3, n)
            Array of column 3D vectors of spherical coordinates
            Vector structure: [r, phi, theta], where
            phi in [-pi, pi],
            theta in [0, pi],
            x = r*cos(theta)*cos(phi),
            y = r*cos(theta)*sin(phi),
            z = r*sin(theta)

        Returns:
        --------
        cart : numpy.ndarray, shape (3, n)
            Array of column 3D vectors of Cartesian coordinates
            Vector structure: [x, y, z]

    tand(x: Union[float, numpy.ndarray]) -> Union[float, numpy.ndarray]
        Tangent of a degree argument.

        Parameters:
        -----------
        x : float, numpy.ndarray
            Angle or an array of angles in degrees.

        Returns:
        --------
        s : float, numpy.ndarray
            A tangent or array of tangents of angles in degrees.

    time2jd(time: datetime.datetime) -> float
        Usual date and time to Julian date.

        Parameters:
        -----------
        time : datetime.datetime
            Date and time object of type datetime.datetime

        Returns:
        --------
        jd : float
            Julian date

        Examples:
        ---------
        time2jd(datetime.datetime(2022, 11, 22, 0, 0, 0, 0))
            2459905.5

    to_float(*args: Any) -> tuple
        Convert all arguments to the float64 type.

        Parameters:
        -----------
        *args
            Arguments separated by comma to convert to float64.

        Returns:
        float_args : tuple
            Converted to float64 arguments.

    units(*args: str) -> dict
        Get units of distance, velocity, and time.

        Parameters:
        -----------
        *args
            Name of pair of names of a celestial bodies

        Returns:
        --------
        units : dict
            A dictionary containing the units of distance, velocity, and time.
